# 2025.3.30 update



当前是4个CPU，当前如果在4个CPU调度队列上使用RR时,我们初始化的时候的给4个CPU都配置了RR的调度模式，我们默认系统原子单位时间为100ms，每100ms触发一次时钟中断
其中对应需要被调度的机器指令为C <time>#
其中R/W/D三者默认为中断触发指令，不服从RR调度

例如：
当进程请求 I/O 时：

1.进程会进入阻塞（Blocked）状态，暂停使用 CPU，等待 I/O 完成。

2.I/O 设备执行 I/O 操作（1000ms），此过程不占用 CPU，而是由DMA 控制器或 I/O 设备自行完成。

3.其他进程会继续按照 RR 轮流执行，不会拆分 I/O 操作。

4.当 I/O 完成时，I/O 设备会发送I/O 完成中断，让进程重新进入就绪队列，等待下一个 CPU 时间片。


然后还要一个需要注意的问题是，每个进程判断应当符合单位时间片不可分的原则。

同时注意我们PCB中的`originalInstruction`和`remainInstruction`两个指令，前者保存原`C <originalExecTime>`类似执行指令，后者保存剩余指令,类似`C <remainTime>`，在任何模式下，执行指令C的时候，如果当前对应进程的PCB的`remainInstruction`不为空，则优先执行这里面的内容，最后将执行后的结果赋值回去，但是如果赋值回去的对应的`remainTime`为空则需要将对应`remainInstruction`置为空。

当前`InstructionFetch`逻辑是如果`remainInstruction`还有内容就需要优先返回这里面的指令，为空的话再向pc++的地址获取下一个指令

## 修改内容：

1.目前新增的cpu个数选择模式，方便测试，由于多级调度只有4个队列，所以目前cpu只支持4个以内。
2.同时完成deviceManager支持deviceId和deviceName管理的设备不重复（单独其中一个参数可以重复，但是两者一起组成是唯一的）
3.完善CPU中机器指令D,现在最新指令格式为` D <deviceName> <deviceId> <ioTime>`

4.完善shell中的exec指令，目前可以支持 `exec <filename1> <priority1> [<filename2> <priority2> ...]`多个文件同时进行

5.支持调度模式当前支持RR+时钟中断

## 问题：

1.exec完打印完消息后，不会主动出现/root>,再回车之后提示Unknow command之后才出来输入提示

2.好像还缺`pwd`指令，同时`cd`指令似乎不能支持带路径的cd？

3.linux好像可以支持`vi <filename>`直接新建文件，可以考虑完善一点细节











## 测试样例

### 设备增删单cpu测试（正确）：

**输入：**

```
1
4
addevc keyboard 0
mkf a 1
vi a
D keyboard 0 2000#C 1000#Q#
:wq
exec a 1

rmdevc keyboard 0
exec a 1
```

**第一次exec输出：**

```
进程 1 加入优先级为 0 的就绪队列
调度器分配进程 1 到 CPU-0
CPU-0 开始执行进程 1
创建进程 1，执行文件: a，优先级为 1
/root> D keyboard 0 2000
CPU-0 执行指令: D keyboard 0 2000
CPU-0 进程 1 请求设备 keyboard 0 进行I/O操作，预计耗时: 2000ms
CPU-0 进入空闲状态
进程 1 加入优先级为 0 的就绪队列
调度器分配进程 1 到 CPU-0
CPU-0 开始执行进程 1
C 1000
CPU-0 执行指令: C 1000
Q
CPU-0 执行指令: Q
CPU-0 进程 1 执行结束指令，即将退出
进程 1 的所有文件锁已释放
CPU-0 进入空闲状态

```

**第二次exec结果：**

```
进程 1 加入优先级为 0 的就绪队列
调度器分配进程 1 到 CPU-0
CPU-0 开始执行进程 1
创建进程 1，执行文件: a，优先级为 1
/root> D keyboard 0 2000
CPU-0 执行指令: D keyboard 0 2000
CPU-0 进程 1 请求设备 keyboard 0 进行I/O操作，预计耗时: 2000ms
CPU-0 请求的设备 0 不存在
C 1000
CPU-0 执行指令: C 1000
Q
CPU-0 执行指令: Q
CPU-0 进程 1 执行结束指令，即将退出
进程 1 的所有文件锁已释放
CPU-0 进入空闲状态
```

### 带设备I/O中断的非抢占式优先级调度单cpu测试（正确）：

**输入：**

```
1
4
addevc keyboard 0
mkf a 1
vi a
D keyboard 0 2000#C 1000#Q#
:wq

mkf b 1
vi b
C 1000#Q#
:wq

```





**第一次exec输出：**


```
/root> exec a 1 b 2
进程 1 加入优先级为 0 的就绪队列
调度器分配进程 1 到 CPU-0
CPU-0 开始执行进程 1
创建进程 1，执行文件: a，优先级为 1
进程 2 加入优先级为 0 的就绪队列
创建进程 2，执行文件: b，优先级为 2
/root> D keyboard 0 2000
CPU-0 执行指令: D keyboard 0 2000
CPU-0 进程 1 请求设备 keyboard 0 进行I/O操作，预计耗时: 2000ms
CPU-0 开始执行进程 2
C 1000
CPU-0 执行指令: C 1000
Q
CPU-0 执行指令: Q
CPU-0 进程 2 执行结束指令，即将退出
进程 2 的所有文件锁已释放
CPU-0 进入空闲状态
进程 1 加入优先级为 0 的就绪队列
调度器分配进程 1 到 CPU-0
CPU-0 开始执行进程 1
C 1000
CPU-0 执行指令: C 1000
Q
CPU-0 执行指令: Q
CPU-0 进程 1 执行结束指令，即将退出
进程 1 的所有文件锁已释放
CPU-0 进入空闲状态
```

**第二次exec执行结果：**

```
/root> exec a 2 b 1
进程 1 加入优先级为 0 的就绪队列
调度器分配进程 1 到 CPU-0
CPU-0 开始执行进程 1
创建进程 1，执行文件: a，优先级为 2
进程 2 加入优先级为 0 的就绪队列
创建进程 2，执行文件: b，优先级为 1
/root> D keyboard 0 2000
CPU-0 执行指令: D keyboard 0 2000
CPU-0 进程 1 请求设备 keyboard 0 进行I/O操作，预计耗时: 2000ms
CPU-0 开始执行进程 2
C 1000
CPU-0 执行指令: C 1000
Q
CPU-0 执行指令: Q
CPU-0 进程 2 执行结束指令，即将退出
进程 2 的所有文件锁已释放
CPU-0 进入空闲状态
进程 1 加入优先级为 0 的就绪队列
调度器分配进程 1 到 CPU-0
CPU-0 开始执行进程 1
C 1000
CPU-0 执行指令: C 1000
Q
CPU-0 执行指令: Q
CPU-0 进程 1 执行结束指令，即将退出
进程 1 的所有文件锁已释放
CPU-0 进入空闲状态

```



### RR+时钟中断单cpu测试（正确）

**输入：**

```
1
3
mkf a 1
mkf b 1
vi a
C 300#Q#
:wq
vi b
C 400#Q#
:wq

 exec a 1 b 1
```

**执行结果:**

```
进程 1 加入优先级为 0 的就绪队列
调度器分配进程 1 到 CPU-0
CPU-0 开始执行进程 1
创建进程 1，执行文件: a，优先级为 1
进程 2 加入优先级为 0 的就绪队列
创建进程 2，执行文件: b，优先级为 1
/root> C 300
CPU-0 执行指令: C 300
CPU-0 时钟中断：进程 1 已使用时间片 100/100
CPU-0 进程 1 时间片用尽，进行进程切换
进程 1 加入优先级为 0 的就绪队列
CPU-0 开始执行进程 2
C 400
CPU-0 执行指令: C 400
CPU-0 时钟中断：进程 2 已使用时间片 100/100
CPU-0 进程 2 时间片用尽，进行进程切换
进程 2 加入优先级为 0 的就绪队列
CPU-0 开始执行进程 1
CPU-0 执行指令: C 200
CPU-0 时钟中断：进程 1 已使用时间片 200/100
CPU-0 进程 1 时间片用尽，进行进程切换
进程 1 加入优先级为 0 的就绪队列
CPU-0 开始执行进程 2
CPU-0 执行指令: C 300
CPU-0 时钟中断：进程 2 已使用时间片 200/100
CPU-0 进程 2 时间片用尽，进行进程切换
进程 2 加入优先级为 0 的就绪队列
CPU-0 开始执行进程 1
CPU-0 执行指令: C 100
CPU-0 时钟中断：进程 1 已使用时间片 300/100
CPU-0 进程 1 时间片用尽，进行进程切换
进程 1 加入优先级为 0 的就绪队列
CPU-0 开始执行进程 2
CPU-0 执行指令: C 200
CPU-0 时钟中断：进程 2 已使用时间片 300/100
CPU-0 进程 2 时间片用尽，进行进程切换
进程 2 加入优先级为 0 的就绪队列
CPU-0 开始执行进程 1
Q
CPU-0 执行指令: Q
CPU-0 进程 1 执行结束指令，即将退出
进程 1 的所有文件锁已释放
CPU-0 开始执行进程 2
CPU-0 执行指令: C 100
CPU-0 时钟中断：进程 2 已使用时间片 400/100
CPU-0 进程 2 时间片用尽，进行进程切换
进程 2 加入优先级为 0 的就绪队列
CPU-0 开始执行进程 2
Q
CPU-0 执行指令: Q
CPU-0 进程 2 执行结束指令，即将退出
进程 2 的所有文件锁已释放
CPU-0 进入空闲状态
```

